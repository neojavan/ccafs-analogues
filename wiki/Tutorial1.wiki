#A first tutorial on how to use the analogues tool

= Installing the package =

Download the package from the download section of this repository. 

== Unix ==
Use the command line and type:
{{{ 
R CMD INSTALL analogues_x.x.x.tar.gz 
}}}
== Windows ==
Start R and install the package with:
{{{
install.packages("analogues.zip", repos=NULL")
}}}
== Climate Data ==
We provide a limited set of climate data also in the download section of this repository. This contains global data (at 0.5 degree resolution) for the monthly mean temperature (tmean), monthly temperature range (dtr) and the monthly precipitation (prec). The data is provided for current climate and for 24 GCMS of the SRES A1B for 2030. 

= Looking for analogues sites =

Start *R* and make sure your have the following library installed: `raster`, `stringr`, `maptools`, `maps`, `spgrass6`, `akima`, `grid`, `rimage`. 

If you are not sure that you have all packages installed just run: 
{{{
install.packages(c("raster", "stringr", "maptools", "maps", "spgrass6", "akima", "grid", "rimage"))
}}}

Next load the analogues packages:
{{{
library(analogues)
}}}

== Initialise a model ==

We always need to set some parameters for each model. To do this, we make use of the `createParameters()` function.

{{{
params <- createParameters(x=10,   
  y=48, 
  to=NA,                       
  method="ccafs",                
  hal.rad=c(NA,0.15),                    
  hal.mad=c(NA,0.3),            
  hal.mrd=c(1,NA),           
  z=2,
  gcms=c("current", "a1b_2020_2049_miroc3_2_hires", "a1b_2020_2049_gfdl_cm2_1"),
  vars=c("tmean", "prec"),        
  weights=c("dtr",1),
  ndivisions=12,                  
  climate.data="current_a1b_2030",              
  ext="asc",
  direction="backwd",             
  growing.season=c(8:12,1:2),           
  across.year=T,
  keep.lag=F,
  normalise=F)
}}}
The meaning of each arguments is not discussed in more details here. To get more information about each argument use `?createParameters`. 

== Load Data ==
Once we created an object holding all parameters, here we called it `params`, we can load the required data. We will create to more variables. The first one called `training` will hold all the rasters required to train the model. In our case these are mean temperature and precipitation. And a second variable called `weights` storing weights for each variable.
{{{
training <- loadData(params)
weights <- loadWeights(params)
}}}

== Looking for dissimilarities ==
Finally we can calculate global dissimilarities and store the list in `res1`
{{{
res1 <- dissimilarity(params,training, weights)
}}}

== Looking for dissimilarities using Hallegates method ==

If we just want want to start from a different point, use a different growing season or method, we can change that accordingly within the parameters object. Here we want to calculate the same analysis, but with Hallegates method. 

{{{
params$method <- "hal"
res2 <- dissimilarity(params,training, weights)
}}}

== Structure of resutls ==
The `dissimilarity` function returns a list of `RasterLayers` or `RasterBricks`. We can inspect the results by:
{{{
> res1
[[1]]
class       : RasterBrick 
dimensions  : 300, 720, 1  (nrow, ncol, nlayers)
resolution  : 0.5, 0.5  (x, y)
extent      : -180, 180, -60, 90  (xmin, xmax, ymin, ymax)
projection  : NA 
values      : in memory
min values  : 16 
max values  : 2088 


[[2]]
class       : RasterBrick 
dimensions  : 300, 720, 1  (nrow, ncol, nlayers)
resolution  : 0.5, 0.5  (x, y)
extent      : -180, 180, -60, 90  (xmin, xmax, ymin, ymax)
projection  : NA 
values      : in memory
min values  : 18 
max values  : 2052 
}}}
Since we used current climate, two future gcms and as a method backward, each of the two elements of `res1` are the dissimilarities between our site and the two future gcms. That means, the lower the value in a raster cell is, the more similar is the current climate of this cell to our cells future climate. 

== Summarising results ==
To summarise the results over the two gcms we make use of the `summariseRuns()` function.
{{{
res1_sum <- summariseRuns(res1)
}}}
The `summariseRuns()` function takes list of rasters as an argument and returns a list with the mean, standard deviation and coefficient of variation. We can either provide it directly with the `res1` list, that resulted from the dissimilarity calculations or we could also provide a set of separate rasters, as long as they have the same extent.
{{{
res1_sum1 <- summariseRuns(list(res1[[1]], res1[[1]], res1[[2]]))
}}}
In the above example we make use of the same `res1` list, but by providing the first element twice, we weight the first result twice as much as the second one. 

== Cropping Results to area of interest ==
If we are only interested in a specific region of interest we can crop the results to that region. This can either be done interactively with the `cropInteractive()` function or with the `crop()` function from the raster package. Here we will crop the the mean prediction interactively and then make use of this extent to apply it to all other results.
{{{
res1_sum_mean_cropped <- cropInteractive(res1_sum$mean)
}}}

== Applying a threshold ==
If we are not interested in the full extent of dissimilarity, we can apply a threshold. This can be done either with the a percentage of terrestrial pixels within a raster or with a range of values.
We will first threshold pixels with a dissimilarity between 0 and 500:
{{{
res1_sum_mean_cropped_th100 <- applyThreshold(res1_sum_mean_cropped,range=c(0,100))
}}}
and the best 5% of pixels within this raster:
{{{
res1_sum_mean_cropped_th5p <- applyThreshold(res1_sum_mean_cropped, best=0.05)
}}}

== Creating a report ==
(not 100 % working yet)
Once we have run one or more models, we can create a report. The report function takes a list of models. Each model consists of params, training data, results, caption of the model and caption of each results). 

{{{
model1 <- list(params=params, training=training, results=list(res1_sum$mean, res1_sum_mean_cropped_th5p, res1_sum_mean_cropped), m.lab="2030", r.lab=c("mean", "cropped: 5% best", "only cropped"))
report(list(model1), "report1.pdf")
}}}
== Export an ESRI ascii Grid for further use in any GIS ==
In order to export dissimilarities as a grid, we can make use of the `writeRaster` function of the `raster` package.  
{{{
writeRaster(res_sum_mean_cropped_th100, filename="analogues.asc", format="ascii")
}}}